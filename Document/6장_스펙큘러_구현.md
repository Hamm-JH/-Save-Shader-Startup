# 6장 스펙큘러 구현



- 4, 5장에 이어 6장에선, 셰이더에 스펙큘러 항을 어떻게 집어넣는지 확인한다.



[기본 라이팅 계산(파트 2)](#기본 라이팅 계산(파트 2))

​	[스펙큘러](#스펙큘러)

[최초 유니티 라이팅 셰이더(파트 2)](#최초 유니티 라이팅 셰이더(파트 2))

​	[스펙큘러 구현](#스펙큘러 구현)

[더 많은 광원 지원하기](#더 많은 광원 지원하기)

[요약](#요약)



## 기본 라이팅 계산(파트 2)



### 스펙큘러

스펙큘러는 시야가 스펙큘러의 방향 벡터가 평행일 때만 볼 수 있을것

- 이를 뷰 종속(view-dependent)라고 한다.

디퓨즈 라이팅은 표준 라이트맵에 미리 세팅 가능

- 스펙큘러의 경우 미리 구워두고, 실시간 계산이 필요하다.

우리가 사용가능한 가장 간단한 스펙큘러 공식 중 하나가 퐁Phong이다.


$$
R = 2\times (N\cdot L)\times N - L
$$

이게 반사 벡터다.

- 빛의 방향 벡터와 노멀 벡터의 내적에 2를 곱한다. [ 2 x (N * L) ]
- 다시 노멀 벡터의 외적을 구한다. [ * N ]
- 거기에 빛의 방향 벡터를 뺀다. [ - L ]

많은 셰이더 언어에서 이 공식을 구현한 내장 함수가 존재한다.

- 보통 함수 이름이 reflect로 정의되어있다.

```C#
float3 reflectionVector = reflect(-lightDir, normal);
float specDot = max(dot(reflectionVector, eyedir), 0.0);
float spec = pow(specDot, specExponent)
```



퐁 구현 위해 먼저 거울 반사 벡터 계산 필요

그 후, 반사 벡터와 뷰 벡터의 내적 계산

- 이 점이 스펙큘러의 뷰종속 부분.
- 이 값을 셰이더 속성에서 선택한 값으로 지수승한다.

★ 이 방식이 특정 측면에서 물리법칙에 위배되는지 확인한다.

- 후에 물리 기반 셰이딩 법칙을 따르도록 수정시 간단한 퐁 셰이딩도 더 사실적으로 보일 수 있다.



### 최초 유니티 라이팅 셰이더(파트 2)

이전 장의 디퓨즈 셰이더에 스펙큘러 항을 추가할 예정이다.




### 스펙큘러 구현

신규 재질을 생성하고 이름을 SpecularMaterial이라고 짓는다.

DiffuseShader3을 복제하고 복제한 셰이더 이름을 SpecularShader로 이름을 변경한다.

[SpecularShader 작성, 작성된 셰이더 참조]



<p align="center">
    <img src="Images/Chap6/6장 SpecularShader 오리.PNG"/>
</p>



비물리 기반 퐁 스펙큘러를 충실히 구현했다.

지금까지 오직 한 가지 빛만 지원했었다.

하지만 지금부터 ForwardAdd 패스를 추가해 씬에 하나 이상의 광원을 지원할 것이다.

이제 이 셰이더에 ForwardAdd 패스를 추가한다.



## 더 많은 광원 지원하기

조심할 점 : ForwardAdd는 따로 분리된 패스

분리된 패스에 엠비언트를 한 번 더 넣을 필요는 없다.

[SpecularShaderForwardAdd 작성, 설명 작성중 p128]



<p align="Center">
    <img src="Images/Chap6/6장 SpecularShaderForwardAdd.PNG"/>
</p>





## 요약

6장에서는 스펙큘러의 가장 단순한 버전인 퐁을 구현했다.

그리고 이후에 셰이더에서 다중 광원 지원을 추가했다.

- 그 결과 긴 중복 코드 생김

7장에서 공간 변환 작업의 일부를 돕는 표면 셰이더(surface shaders) 소개 예정

이를 활용해 다중 광원 지원 코드에 있던 많은 중복 코드 제거 가능하다.